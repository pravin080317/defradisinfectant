Got it. I’ll compile a comprehensive list of map UI and data requirements observed in the screenshots and meeting notes, and map those requirements against feasibility across Canvas App native controls, PCF (custom map component), Power BI embedding, and external embedding (e.g. Esri or geo viewer apps). I’ll also provide a recommendation note on adopting an MVP-first approach.

I’ll get back to you shortly with a structured feasibility grid and notes.


# Feasibility Comparison of Mapping Implementation Options for Revaluation Tools

During the Council Tax Revaluation **Stand Back and Look (SBL)** design sessions, several advanced mapping features were identified for the Sales Verification Tool (SVT) and Revaluation UI. Key expected capabilities include: color-coded **clickable pins** on a map (by band), **synchronized filtering** between map and property tables, the ability to **draw polygons** or select by area, **radius-based filtering** (e.g. 200m comparable searches), interactive **drag-and-drop graph** adjustments (for thresholds/outliers), a map **legend** for band colors, and **smooth, real-time updates** to charts as data or selections change. Achieving these in a Canvas App requires evaluating four implementation paths:

**1. Canvas App OOB Map Control** (built-in Bing Maps control)
**2. Custom PCF Map Control** (PowerApps Component Framework with React/TS)
**3. Embedded Power BI Map/Report**
**4. Embedded External Web Map** (e.g. an Esri or existing CTB Geo viewer)

Below is a detailed feasibility matrix mapping each required feature against these options, followed by analysis of data latency, performance, reuse of existing tools, Canvas integration, and a recommended approach.

## Feasibility Matrix: Mapping Requirements vs Implementation Options

| **Feature Requirement**                                                       | **Canvas App OOB Map** (Bing Maps Control)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | **Custom PCF Map Control** (React/TS)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | **Embedded Power BI** (Map in PBI report)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | **External Web Map** (Esri/CTB viewer)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Clickable Map Pins** (select a property on map)                             | **Limited:** Basic pins can be shown for addresses, but OOB Canvas map offers minimal interactivity. No native *OnSelect* event for map pins, so clicking a point cannot directly trigger Canvas logic. Interaction is mostly view-only (just a static map with pushpins) – making true click-selection infeasible without workarounds.                                                                                                                                                                                                                                                                                                                           | **Yes:** A PCF map can be coded to handle click events on markers (e.g. using Leaflet or Mapbox libraries). Selected pin details (UARN or coordinates) can be passed back to Canvas via PCF outputs, enabling highlight of the corresponding record in a gallery/table. This fully supports interactive selection with custom pop-ups or styling on selection.                                                                                                                                                                                                                                                                                                                                                                                                                       | **Partial:** In an embedded Power BI map visual, clicking a pin will cross-filter other visuals *within the Power BI report* (e.g. highlight that property in a PBI table) but **cannot directly notify the Canvas App** of the selection. The map and table would likely both reside inside the PBI report for interactivity, reducing Canvas control. Moreover, customizing pin behavior beyond default tooltip info is limited in PBI.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | **Yes:** An external web map can provide rich interactivity – e.g. clickable markers that show property info and send selection events. If embedded via an HTML container or iframe, it can communicate selection (e.g. via postMessage) to the Canvas app or update a linked data source. This approach was envisioned with the Geo team’s viewer: *the Canvas passes parameters (like batch ID) to an embedded Geo UI and the external component handles all interaction*. Proper messaging integration is needed, but fully achievable.                                                                                                                                                                                                                                                                                                                                                                                  |
| **Map-to-Table Sync** (bi-directional filtering between map and list)         | **No native sync:** Canvas OOB map has no built-in connection to other controls. Filtering must be manual – e.g. use the same filter criteria for both a data table *and* the map’s Items property. The map won’t automatically highlight selected records from a gallery. At best, one could show pins based on the gallery selection, but dynamic sync (click map => filter table, or select table => pin highlight) is not supported out-of-box.                                                                                                                                                                                                               | **Yes (with custom logic):** A PCF can be designed to accept a list of records (for map plotting) and an input for “selected record” to highlight. Likewise it can output events (like polygon drawn or pin clicked) that the Canvas uses to filter its table. This requires custom coding: e.g. when a user draws an area in the PCF map, the PCF computes the included UARNs and sets an output property (list of IDs) which the Canvas App uses to filter the gallery. This achieves true two-way coupling, but it’s a **significant custom dev effort** to implement and test all sync scenarios.                                                                                                                                                                                | **Partial (within PBI only):** If map and table are visuals in the same Power BI embedded report, selecting one will filter the other **within that report** (thanks to built-in cross-filtering). However, this synchrony does not extend to Canvas App components outside the PBI embed. The Canvas App cannot easily respond to PBI visual selections in real-time. (One could attempt workarounds like Power BI’s integration APIs, but this adds complexity and still wouldn’t feel seamless.) Essentially, you’d be confining interactive filtering to inside the Power BI iframe – limiting the Canvas’ role.                                                                                                                                                                                                                                                                                                                                                                                                            | **Yes (with integration):** An external map app can be built to sync with a separate table UI, but coordination is needed. The simplest approach: **integrate the table into the external component itself**, so one embedded web UI contains both map and list that filter each other (much like a mini web app within the Canvas). This ensures smooth internal sync (like how the current SBL tool’s map and table reflect the same filters). Alternatively, if the table remains a Canvas element, the external map can send messages (selected IDs or filter criteria) to the Canvas (through a custom channel or a PCF bridge) to apply filters, and vice-versa. This is feasible but requires a messaging protocol and possibly a PCF wrapper for the iframe.                                                                                                                                                        |
| **Polygon Drawing & Selection** (lasso an area to select multiple properties) | **Not Supported:** The out-of-box Canvas map does *not* allow drawing shapes or selecting multiple points by area. It’s a static control without GIS editing tools. Any notion of lassoing a region or drawing a polygon would require custom code – impossible with the native control.                                                                                                                                                                                                                                                                                                                                                                          | **Yes (Custom):** PCF can incorporate map drawing libraries (e.g. Leaflet.draw or Mapbox GL Draw) to let users sketch polygons or lasso areas. The PCF could then calculate which properties fall within the shape (using client-side point-in-polygon logic or by calling a spatial API) and return those as a selected set. Implementing this will require advanced coding and possibly using spatial indexes (for performance with many points) in the PCF, but **it is achievable**. The complexity is high, but this approach gives full control to meet the requirement.                                                                                                                                                                                                       | **No:** Power BI map visuals do not support arbitrary polygon drawing by users. At most, they allow rectangular *lasso select* on some visuals, but not persistent polygon shapes. There’s no facility for a user-drawn area that filters data beyond clicking individual points or using predefined geographic boundaries. This requirement cannot be met in PBI without extremely custom approaches (e.g. a separate GIS tool feeding results to PBI), which defeats the purpose.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **Yes:** Most external web mapping frameworks (Esri JS API, Leaflet, etc.) support drawing tools natively. The existing GEO/CTB viewer *already provides polygon draw/select for comps*. Reusing that, an external map can let the user draw an area and then filter or highlight all properties in that polygon. Since this feature already exists in the Geo team’s comparables tool (they demonstrated selecting properties within a drawn polygon after a radius search), it’s clearly feasible to include in the Revaluation map if using the external approach.                                                                                                                                                                                                                                                                                                                                                       |
| **Radius-Based Filtering** (e.g. “show all properties within 200m”)           | **No (not out-of-box):** The Canvas map control can display points, but cannot perform spatial queries (like computing distance filters). You would have to manually compute which records fall in a radius (via a separate data layer or query) and then supply those to the map. There’s no built-in radius tool where a user clicks and sees a circle or results – you’d need to create a custom workaround (e.g. have user input a central address and call a flow to fetch nearby points). This is beyond OOB capabilities.                                                                                                                                  | **Yes:** A PCF map could implement an interactive radius query. For example, on pin click, the PCF could call a backend API (or use a pre-loaded spatial index) to retrieve all properties within X meters and then plot them/highlight them. Alternatively, the PCF could draw a circle of specified radius and filter the points it already has. The Geo team’s method for 200m search (sending map bounds to a PostGIS query via API) could be invoked from the PCF as well. So technically this is feasible, though it requires integrating with spatial query logic (PostgreSQL/PostGIS via an API) or bundling a simpler distance calc in the PCF.                                                                                                                             | **Limited:** Power BI could filter by distance only if the data model is prepared for it (e.g. having precomputed distances or using a custom slicer). There’s no interactive “draw radius” on a PBI map. At best, a user could select a point and manually use a slider for distance if such a parameter is wired up in the report, but it’s very clunky. Essentially, PBI isn’t suited for on-the-fly spatial filtering – it would require complex DAX or a pre-loaded table of neighbor relationships. This dynamic GIS query is outside PBI’s typical use case.                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **Yes:** The existing external tools already handle radius filtering. The GEO team’s comparable sales viewer accepts a radius (200m) and returns all properties in that range. An external map can easily incorporate a radius selection UI – e.g. user picks a point (or a property) and the map draws a 200m circle and highlights included properties. The heavy lifting (spatial query) can be done server-side (PostGIS via a VaaS API) as currently implemented, ensuring performance. This approach is proven in the current comparables workflow, making it a strong option for re-use.                                                                                                                                                                                                                                                                                                                             |
| **Drag-and-Drop Graph Interaction** (e.g. adjust a line or point on a chart)  | **No:** Canvas Apps cannot provide drag-drop interactions on charts. The platform’s chart controls (or using images/shapes) are static. There is *no support for grabbing a data point or threshold line and moving it* to update values. The design team explicitly noted such interactive charts “do not exist in Canvas”. Achieving this natively is impossible.                                                                                                                                                                                                                                                                                               | **Yes (with effort):** A PCF could render a custom chart (using D3, Chart.js, etc.) where points or reference lines are draggable. For example, showing a scatter or line chart of valuation metrics with a movable threshold line – the PCF could capture the drag event and recalc metrics in real-time. This is complex but feasible in code. It would effectively mean building a bespoke charting component. The PCF could then output the new threshold or selections to Canvas (or even call an API to re-fetch data based on the new parameter). This is a heavy custom development, but technically achievable since PCFs can handle any HTML/JS logic needed.                                                                                                              | **No:** Power BI visuals do not allow users to manipulate the data or visual elements by dragging. All interactions are limited to filtering or highlighting existing data points. For instance, you cannot let a user arbitrarily drag a point on a line chart to change a value/threshold – PBI is read-only in this regard. (What-if parameters in PBI can be adjusted via sliders or input boxes, but not by directly dragging chart elements, and they are not very real-time.) This requirement is completely out of scope for PBI.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | **Yes:** An external web app can implement interactive graphs using JavaScript libraries. If the Graph UI team has existing components (the discussion mentions a **Graph UI** under approval), those could allow dynamic chart manipulation. In an external setting, one could, for example, embed a D3 chart where the user drags a marker to change a cutoff, triggering immediate updates to related charts or maps. The transcript confirms that such dynamic charts and drag/drop “**will not be built in Canvas Apps**” but rather provided via Graph/Geo HTML components. Thus, embedding an external graph component is the intended solution for this requirement.                                                                                                                                                                                                                                                |
| **Map Legend (Band Color Key)**                                               | **Partial:** The built-in map control itself does not generate legends. A static legend (colored labels for A–E bands) would need to be manually created in Canvas (e.g. using icons or shapes and text). This is doable, but if the color scheme or categories ever change dynamically, the Canvas app logic must update those controls too. OOB maps won’t auto-produce a legend for custom data layers.                                                                                                                                                                                                                                                        | **Yes:** Since a PCF map is fully custom, you can programmatically generate a legend. For example, if bands A–E correspond to colors, the PCF’s React code can render a legend box on the map (or as part of the component UI) showing color swatches and labels. This can even be dynamic (e.g. only show bands present in the current view) if desired. It’s additional coding but straightforward to include (the SBL example had a fixed legend for bands which could be replicated).                                                                                                                                                                                                                                                                                            | **Yes:** In Power BI, a map visual using categories will typically display a legend (e.g. band colors with labels) by default. For instance, a Filled Map or scatter map colored by band would show a color legend for the bands. This is one aspect PBI can handle easily. The legend styling is PBI-controlled, but it will match the data categories and colors. So, PBI meets this requirement out-of-the-box if the data is categorized by band.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **Yes:** An external map UI can include a legend overlay. If reusing the CTB viewer or Esri map, a legend for band colors can be added via the mapping library’s API or a simple HTML/CSS element. Since the band-color mapping is known (A=Grey, B=Blue, C=Purple, D=Pink, E=Yellow in SBL), the external tool can hard-code or dynamically render a legend. This was present in the existing SBL tool (the screenshot showed a color key at the bottom) and can be reproduced in a custom web map easily.                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **Smooth Chart Updates** (fast, fluid UI when filters change)                 | **Challenging:** Canvas Apps can update visual controls when variables change, but performance can suffer with large data sets or frequent updates. There is notable latency when dealing with many data points due to Canvas’s 500/2000 record delegation limits and its in-memory nature. For example, if applying a new filter, the map control and any chart elements might visibly lag while recalculating, especially if the app must call an API or process data in Power Fx. Smooth, animated transitions (like a seamless update of a chart or map zoom) are not native to Canvas controls. The experience may feel “clunky” compared to a true web app. | **Good:** A well-built PCF can handle updates efficiently on the client side. Since PCF components run as minified HTML/JS, they can leverage techniques like data virtualization or incremental rendering. For instance, a PCF map could implement point clustering and only redraw the subset of points that changed on a filter, making updates appear instantaneous. Charts in PCF can be animated for smooth transitions. **However,** if the PCF relies on re-fetching data via Canvas on every filter, network latency could still introduce delay. Caching data in the PCF or using local state can mitigate this. Overall, a PCF can deliver much smoother UI interactions than pure Canvas, but it requires careful optimization for large datasets (thousands of points). | **Good within PBI, but static relative to Canvas:** Power BI is optimized for rendering visuals with moderate volumes of data and has built-in cross-filtering animations. Selecting a filter in a PBI report will typically update charts and maps with minimal lag (since it’s using an internal columnar engine). The transitions (highlighting, etc.) are smooth. **However,** the responsiveness depends on data model size and whether using DirectQuery (which can be slower). More importantly, if the user triggers a data refresh (to get latest bands), PBI will **not** update smoothly – it requires a dataset refresh cycle. PBI is smooth for in-session filtering of already-loaded data, but not suitable for live data updates. In context, the existing SBL tool accepts that data only refreshes twice a day, which would be similar if we rely on a PBI dataset (not real-time). So while UI interactions in PBI are fluid, the **data latency** (covered below) makes truly real-time updates infeasible. | **Excellent:** A purpose-built external web app can provide the most responsive experience. Since it can maintain its own optimized data store (or use on-the-fly API calls), it can update the map and charts very smoothly. The GEO team’s JavaScript viewers are designed for interactive use – e.g. their map updates the view instantly when a radius filter is applied. Using modern web tech (Angular/React with state management, or even an Esri map which handles zoom/pan smoothly), the UI can feel snappy even with large data volumes by using techniques like tiling or clustering. We can also ensure charts update in sync with map actions in a coordinated way (since one team controls both in the external component). In short, an external embedded UI can be as smooth as a typical web GIS application, given proper optimization and the fact that it’s not constrained by Canvas refresh quirks. |

**Table Legend:** *“Yes” = fully supports the feature natively or with acceptable effort; “No” = cannot realistically support the feature; “Partial/Limited” = some aspects supported, but significant limitations or not a complete solution.*

## Data Refresh & Latency Considerations

One major factor is how up-to-date the map data will be and how quickly updates propagate across the system. The existing SBL tool works off a **staged dataset updated twice daily (noon and midnight)**. This implies current processes prefer batch updates due to the large data volumes. For the new solution, using **live APIs (VaaS)** on DAP2 means data could be fresher, but each approach handles it differently:

* **Canvas OOB Map:** Would retrieve data via Dataverse or custom connectors at runtime. It could show near-real-time data if calling the API on load/filter, but Canvas has limits on data calls and might not handle continuous real-time streaming. Also, loading a very large dataset (thousands of properties) on demand may hit delegation limits, forcing pre-filtering (e.g. by patch or area). If data changes (e.g. a band edited) and we want to reflect it, the Canvas app would have to re-query or receive a push – which isn’t trivial to do instantly. In practice, we might still rely on periodic refresh actions (e.g. user clicks “Refresh data” to load latest, acknowledging a slight delay).

* **Custom PCF:** A PCF could call the VaaS APIs directly (with appropriate context tokens) or accept data from the Canvas. Either way, it can retrieve and update data on demand. PCFs have the flexibility to implement caching or incremental loads. For example, the PCF might initially load summary data or only properties in the current view, and fetch more as the user zooms or filters. Data latency here is largely network-bound – a well-designed PCF can fetch data in the background so that updates (like a new filter selection) feel immediate. Also, a PCF could leverage the **Synapse Link near-real-time feed** if exposed via API to get updates on band changes quickly. The challenge is managing data consistency: ensuring the PCF’s view matches any edits done via the Canvas UI or other processes. This likely means implementing refresh hooks (e.g. after a user submits a rebanding, call refresh on the map’s data).

* **Embedded Power BI:** This option is weakest for real-time data. Power BI typically operates on imported data or scheduled refresh. Unless DirectQuery is used (which would query the source on each interaction), the data could be hours behind. Even with DirectQuery, performance might degrade (multiple queries for each filter action) and still might not show instantaneous *post-edit* updates unless the source transactions commit and propagate immediately. The design team already noted **“Power BI is not suitable due to refresh limitations and lack of real-time interaction”**. Using Power BI would likely force us into a model where the map is only as current as the last refresh (perhaps daily), conflicting with the desire for an interactive tool during revaluation. In summary, data latency is a significant drawback of the PBI approach – it cannot easily match the timeliness of direct API calls.

* **External Web Map:** An external map can directly consume the **VaaS APIs** or other geo-services, meaning it can fetch live data on demand. If a user applies a filter or a batch is updated, the external component could call the API for updated records immediately. This yields low latency for data updates (similar to the PCF case). The external approach might even allow more creative solutions: e.g. subscribe to a SignalR/WebSocket for any new data (if available) or pre-load an entire area’s data in memory for instant filtering. The main consideration is that if the external tool runs outside the Power Platform, authentication and data access must be handled (likely via an authenticated API call using the user’s credentials or a service account). As long as the external tool can query the underlying data service quickly (and perhaps the GEO team’s spatial database for geo-queries), data will be as up-to-date as the source. We must also note any **intentional staging**: if for performance we mimic SBL and only update periodically, that could be done regardless of approach – but ideally we design for near-real-time so that, for example, when a user re-bands a property, they see that change reflected on the map without waiting half a day.

**Summary:** The Canvas/PCF/External paths all can leverage live APIs for low-latency data, whereas a Power BI embed would introduce delays unless carefully configured (and even then, real-time write-back is problematic). This aligns with the consensus from design discussions to use **APIM + VaaS** for data feeds and avoid PBI for interactive scenarios.

## Performance and Scalability (Large Data & Zooming)

Performance is critical, given the potentially large number of properties (entire towns or batches) to display. Key considerations:

* **Rendering Many Points:** If an entire batch or patch might include thousands of properties, the map should handle this without freezing or losing clarity. The **Canvas OOB map** is not optimized for large point sets – it would attempt to plot all pushpins and could easily bog down or hit limits. There is no clustering or tiling mechanism available. In contrast, **PCF** and **External** solutions can leverage web mapping techniques (clustering, tiling, generalization). For instance, a PCF using the Leaflet library could group nearby points into cluster markers when zoomed out, improving performance. An external Esri map could use an ArcGIS feature service or vector tile layer that efficiently loads only visible features as you zoom. The GEO team could also pre-index data by areas to quickly deliver only what’s needed (they already use bounding box queries in Postgres for the radius search). **Power BI** maps have some optimizations (they down-sample points when too many are in view), but the user has no control over that – important outliers might not display if PBI sampling kicks in. Also, PBI’s map visuals have known point count limits (often capping at a few thousand points) for performance, which could be a show-stopper if we need to show *all properties in Wales* in a view.

* **Smooth Zooming and Panning:** Users will expect to pan/zoom the map fluidly. A **Canvas OOB map** does allow basic zoom and pan gestures (since it’s essentially a Bing Maps embed), which are fairly smooth, but again heavy loads could make it sluggish. A **PCF map** using a modern library can ensure smooth transitions – e.g. Mapbox GL uses GPU acceleration for vector maps, giving very fluid zooming even with many points (via WebGL). **External maps** can do the same; Esri’s JavaScript API or OpenLayers are designed for this scenario. **Power BI** maps are less fluid – panning/zooming is possible but not as responsive as a dedicated map app, and there might be a delay as PBI re-renders and fetches data for the new view. For a fluid UX, a specialized mapping component (PCF or external) is preferable.

* **Batch Operations & Overlays:** The mapping tool might also overlay shapes (like highlighting a batch’s boundary or an MSOA boundary for context). Complex polygons or large overlays could further tax the system. **Canvas OOB** likely cannot overlay custom polygons at all (beyond maybe an image background). **PCF/external** can handle overlays – e.g. add a transparent polygon layer for a selected area. Performance will depend on polygon complexity (but typically manageable if simplified geojson). **Power BI** could potentially show boundaries via shape map or filled map visuals, but again with limited interactive control (and adding too many shapes can slow it down).

In summary, to handle **large scale mapping** with good performance, the **custom code approaches (PCF or external)** are far superior. They allow leveraging efficient algorithms and existing GIS infrastructure (like spatial databases and tile services). The transcripts reinforce this, noting that advanced geo-visualizations (like heatmaps or large-scale plotting) would be “too complex within Power Platform” and better done with JavaScript/Geo solutions. The Power BI approach inherently abstracts away performance tuning (which is risky for our use-case), and the Canvas OOB map is a basic control not meant for heavy analytics. Therefore, **scalability and performance needs push us toward PCF or external web maps** where we have full control to optimize.

## Reuse of Existing GEO/CTB Tools

Another key consideration is the opportunity to **reuse components already developed by the GEO or CTB teams**. The design discussions highlighted that the GEO team has built a **comparable sales map viewer** (in JavaScript) and the CTB-T (Council Tax Base Transformation) team has some graph UI components. Leveraging these could jump-start our implementation:

* **External Web Map (Reuse GEO’s viewer):** The GEO team’s tool for sales comparables includes functionality for radius searches and polygon selection. It’s built in JavaScript (likely with a mapping library) and uses the Postgres/PostGIS backend for queries. We can potentially reuse significant parts of this: for example, the front-end code for map rendering and selection, and the backend API for “get properties in radius/polygon”. The transcript confirms this tool already exists and could be customized further for our needs. By embedding this as an **iframe or HTML component** in our Canvas app, we offload the mapping heavy lifting to a proven solution. The GEO team would need to adjust it to accept different parameters (like our batch or patch identifiers) and maybe to output selection back, but this is easier than building from scratch. Essentially, this path **outsources the mapping to specialists** (GEO team) whose solution is already approved for use (the CTB project was built in JavaScript and considered an approved tech stack).

* **Graph/Chart Tools:** The CTB team also apparently built some UI (possibly for graphs or complex charts) in JavaScript. The discussion mentions “Graph UI” being under approval and possibly using a graph database or some library. If the Graph UI team has an interactive chart component (e.g. for viewing valuation distributions or trends) that supports drag-drop, we might reuse it similarly. The idea floated was to embed these as needed rather than re-code in Power Apps. So for the **drag-drop graph requirement**, if CTB or another project already solved something similar (e.g. a threshold slider on a chart), we should incorporate that as an external module.

* **Esri or Other External Tools:** The mention of “Esri-based” map suggests considering commercial GIS solutions. If the organization has an ArcGIS Online or Enterprise setup from CTB or GEO, we could embed an **ArcGIS map widget**. Esri’s advantage is robust features (layer management, fast rendering via their cloud services). However, reusing GEO’s custom solution might be more straightforward since it’s already tailored to VOA data (and presumably doesn’t require new licenses or complex integration – it directly hits Postgres). We should check if the GEO viewer uses any licensed components (it might just be open-source libraries). If an Esri viewer is available (maybe CTB had one for viewing council tax bands on a map), that’s an option – but usually, those would still need embedding via an iframe or a custom PCF wrapper.

In conclusion, **Option 4 (External Web Map)** aligns with reusing existing tools: *“Geo team (using JavaScript and Postgres spatial queries) will expose these as HTML components or hosted UIs, embedded into Canvas Apps.”*. This was explicitly agreed upon in the design sessions as the way forward for maps and advanced visuals, instead of reinventing the wheel in Canvas. Option 2 (PCF) could also reuse some code – e.g. the GEO team’s JavaScript could potentially be wrapped into a PCF control – but that would require more development work to adapt it to PCF constraints. Direct reuse via embedding may be faster and allow the GEO team to continue iterating on their tool independently.

## Integration with Canvas UI (Filtering & Drilldowns)

The ability to have **side-by-side filtering and drilldowns** between the map and other Canvas UI elements (like filter dropdowns, data tables, and forms) is crucial. Here’s how each option fits into the Canvas ecosystem:

* **Canvas OOB Map:** Being a native control, it *lives within the Canvas app’s tree* and can directly read Canvas variables or inputs (for example, you could set the map’s Items property to `Gallery1.AllItems` or to a filtered data source based on dropdown selections). This tight integration is an advantage: when a user changes a filter on the left panel (as described in SBL: Patch, Batch, etc.), the developer can use those values to filter the items shown on the map and in the table in one formula. However, the limitation is mostly one-way – Canvas controls don’t easily emit events. The map control won’t tell the Canvas that “user clicked X”. So filtering typically has to be driven by the Canvas (top-down), not by direct map interactions. In short, OOB control fits in layout and uses Canvas data, but doesn’t contribute much back to the UI events.

* **Custom PCF:** A PCF control is also inserted as a native component on the Canvas (just like a label or button). You can bind it to properties or data sources, and read its output properties in Canvas formulas. This means we can achieve tight coupling: e.g., bind the PCF’s input to the current filter selection (so it knows which properties to load), and bind the Canvas gallery’s Items to the PCF’s output (e.g. a list of selected properties from a polygon). PCFs can have multiple outputs and even trigger Canvas *Behaviors* (though often one uses a polling or variable mechanism). This integration is **bi-directional**: Canvas filters → PCF updates map; PCF interaction → Canvas gets outputs to update other UI. It’s a clean approach, but it requires the PCF to be well-designed with the right properties. The **feasibility check task** noted in the meeting explicitly was to decide which parts go in Canvas vs external – PCF would fall on the Canvas side (for deployment), but functionally it’s providing external-like capabilities. So with PCF, we can get very tight coupling (nearly seamless user experience between map and form), at the cost of custom dev.

* **Embedded Power BI:** Power Apps provides a *Power BI tile* component to embed reports. Integration here is shallow: you can pass **filter context** from the Canvas app to the PBI report (for instance, using the PowerBIIntegration data when embedding in model-driven apps, or setting filters via URL parameters for the tile). So if a user selects a patch in a Canvas dropdown, you might filter the embedded PBI report to that patch. That covers Canvas → PBI direction somewhat. However, going the other way (PBI → Canvas) is not supported out of the box. The PBI report cannot click a point and have Canvas know about it, as mentioned. One could imagine a hack where the PBI writes the selected ID to some shared data source that Canvas is monitoring, but this is overly complex and not real-time. Drilldowns are best kept within the PBI report itself. Therefore, using PBI would likely mean **the map, charts, and table all live inside one embedded report** (to leverage native cross-filter). The Canvas app then becomes mainly a container (maybe with some extra buttons around it). This negates many advantages of Canvas (why not just use PBI Service then?). Also, any *drill to record* action (like clicking an “Edit UARN” link) would be awkward – PBI can’t directly open a Canvas edit form; you’d possibly use a PowerApps visual inside PBI, which becomes an inception of embedding and gets messy. In summary, PBI embedding is **loosely coupled** at best – it doesn’t give the seamless side-by-side interactivity that a custom solution can.

* **External Web Map:** If using a completely external webpage embedded via iframe, integration is the trickiest. By default, an iframe is isolated – the Canvas app won’t know what’s happening inside it. We need a communication mechanism. One approach is using **HTML text control with custom script** (though Power Apps has restrictions on running arbitrary scripts). More robustly, we can create a **PCF wrapper** that hosts the external content in an iframe. This PCF could act as a bridge, using the browser’s postMessage API: the external page and the PCF agree on a message format for selection or filter events. For example, when the user draws a polygon in the external map, the page posts a message “SELECTED\_IDS:\[list…]” to its parent. The PCF code listens and then outputs that list to Canvas. Conversely, when the Canvas needs to send a filter (say the user chose a different batch in a Canvas dropdown), the PCF can post a message into the iframe (e.g. “FILTER\:batch=XYZ”). This kind of messaging integration was hinted at in the plan to *“parameterize”* the embedded Geo viewer. It does add some complexity (needs coordination and testing to ensure secure messaging), but it’s doable. The end result can be nearly as integrated as the PCF approach, just that part of logic runs externally. Notably, if the external map contains its own UI for filtering (say it has a layer toggle or its own dropdowns), we might even decide to let it handle those aspects entirely and not duplicate them in Canvas. In that scenario, the Canvas app might just provide high-level context (like which **batch or patch** is being examined) via an iframe URL param and then the external app manages internal drilldowns. This is the simplest integration (one-way initial parameter passing, no continuous sync). But if we need, for instance, the Canvas table to reflect what polygon user drew on the map, then the full two-way messaging as described is needed. The transcript suggests they aim to embed external components “within your application” but avoid building those features in Canvas itself, which implies they accept a somewhat decoupled approach as long as the user has a unified experience.

Overall, **tight coupling is best achieved by PCF** (or by building everything in one external app). The external iframe approach can be made to work with some messaging glue, while PBI is largely standalone. The Canvas OOB control is integrated but too static to meet our needs. These trade-offs will influence the user experience consistency.

## Recommendation and Next Steps

Considering the above comparisons, the following approach is recommended:

* **MVP (Minimum Viable Product):** Leverage an **embedded external map component** (Option 4) for core functionality, combined with the Canvas app for surrounding UI. This means initially embedding the GEO team’s existing map viewer (or a slightly customized version of it) into the Canvas custom page to display color-coded property pins by band. The MVP map should support basic **view and filter** use cases: e.g. show properties for a selected batch or patch, allow the user to click on a pin to identify the property, and highlight corresponding entries in the Canvas table. We should also include the band **legend** and basic zoom/pan controls, as per the current SBL design. By using the external component out-of-the-box, we can get this running quickly, subject to establishing the embedding mechanism. The MVP would **not initially implement polygon drawing or advanced drag-drop charts** – those can be staged for later. Instead, we could include a simple radius filter tool (since the GEO API already handles a 200m search, we might expose a button like “Show 200m comparables” as a start).

* **Rationale:** This MVP approach aligns with the design consensus that **Canvas is the entry point but complex visuals come from Geo/Graph UIs**. It minimizes custom development in phase 1 by reusing proven components, and avoids the pitfalls of Power BI (which was deemed unsuitable for interactivity). It also sets us up to get user feedback on the embedded map’s usefulness early on, without committing to a fully custom build.

* **Staged Enhancements:** In subsequent iterations, we can progressively enhance the mapping tool:

  * **Polygon Select & Bulk Actions:** Introduce the draw-polygon feature via the external map (or PCF). This would allow selecting a cluster of properties to mark for re-banding in one go. We’d need to connect this to the Canvas side (e.g. populate the selection into the table or trigger a “Create Batch Reband” action). This addresses advanced review scenarios discussed (like re-banding an entire street section identified visually).
  * **Interactive Charts:** Embed the “Graph UI” component (possibly as a second embedded element or integrated into the map UI) to handle things like the **drag-and-drop line chart** for AVM threshold tuning or time series analysis. For example, a chart showing AVM error distribution where a user can drag a cutoff line to see which cases become outliers. This would likely be another custom module provided by the Graph/CTB team. We’d stage this after the basic map is in place, as it’s more complex to implement.
  * **Deeper Canvas Integration:** If the initial iframe approach proves too limiting (e.g. difficulties in syncing selection), we might develop a **PCF version** of the map in a later phase. That PCF could even reuse the external tool’s code (with minor refactoring). This would tighten integration (removing iframe quirks) and possibly improve performance by loading directly in the Canvas context. Essentially, we start with the quickest path (embed existing app) and later consider a **refined PCF implementation** once requirements are solidified and if the user base demands more seamless behavior.
  * **Performance Tuning:** As a later enhancement, consider moving to more scalable data serving if needed (for instance, using a map tile service for base maps or precomputed heatmaps for band distribution). If the dataset is extremely large, we may incorporate techniques like server-side clustering or map generalization in a later phase. Early on, restrict the view by filter (e.g. one batch or patch at a time) to keep performance high.
  * **UI Polish & Legend/Layer Control:** Add nice-to-have features like toggleable map layers (e.g. toggle heatmap vs pins, or show imagery), a dynamic legend that highlights the count of properties in each band currently visible, etc., once the core is stable.

* **Dependencies & Considerations:** To execute this plan, a few dependencies need to be managed:

  * **DAP2 / VaaS API:** The Valuation-as-a-Service APIs must provide the necessary data endpoints (e.g. get properties by area, get property details by ID) for the map tool. If these are not ready, we might temporarily use a static data extract (as SBL did) or a direct read from the curated database for demo purposes. Long-term, the API approach is preferred for security and maintainability.
  * **Geo Service Endpoints:** We should coordinate with the GEO team to access their spatial query endpoints (like the 200m radius search) or incorporate their logic into our API. The action item to *“Confirm PostgreSQL spatial query method for 200m radius”* is pertinent – we need to ensure the method is efficient and accessible. If the GEO team can expose a reusable service (e.g. `/getPropertiesWithin?UARN=x&radius=200`), that would accelerate development.
  * **Authentication & Security:** Embedding an external web app may require single sign-on or API token passing. We need to ensure that the external component can securely call the backend (likely via the user’s credentials through APIM). If hosting externally, we might host it on an internal server or Azure Web App behind our AAD for SSO. All this likely needs architectural approval.
  * **Power Platform Allowances:** Using PCF components or iframes might require environment settings or admin approval. For example, to embed an iframe, we might use a PCF – which means our code must pass the **PowerApps code review** and be deployed in the environment. Early engagement with governance is wise, to get approval for using JavaScript libraries (Leaflet, D3, etc.) either in PCF or external form. The transcript notes that HMRC has approved using JavaScript UIs (the CTB tool proves that), but with correct versions and security – so we must follow those guidelines.
  * **Licensing:** If we choose an Esri solution, ensure the licensing is in place. If reusing internal tools, this is likely already accounted for. Also, if going with Power BI (even though not recommended), it would require a premium capacity or per-user licenses for embedding – another factor that made PBI less attractive.
  * **Collaboration:** We will rely on the GEO/CTB teams for components – their buy-in and timelines are a dependency. It’s important to include them in planning (which the project team is already doing by involving Geo early). Any delays or changes in their deliverables could affect our mapping feature timeline, so a clear interface contract (what the external component will do vs what Canvas does) should be agreed upfront.

Finally, it’s worth noting that **Canvas App remains the orchestrator**: all these enhancements should feel like part of one application to the user. The Canvas app will house the filter panel (patch, batch, etc.), initiate the data load (passing parameters to the map component), and provide action buttons (like “Edit Band” links in the table). Our approach ensures the Canvas app focuses on what it does well – form entry, connecting to Dataverse cases, guiding the workflow – while delegating specialized interactive visuals to purpose-built components. This balanced architecture is in line with the design consensus and offers the best chance of delivering a performant, user-friendly revaluation mapping tool.

**Recommendation Summary:** Proceed with **Option 4 (Embedded External Map)** for the initial implementation, achieving a usable “Stand Back and Look” map with minimal reinvention. **Avoid Option 3 (Power BI)** for anything more than quick prototyping, given its refresh and integration limitations. If needed, later invest in **Option 2 (PCF custom control)** to further integrate and polish the experience, reusing the external tool’s capabilities within the Canvas environment. Ensure necessary **APIs and approvals** are in place (DAP2 data access, geo queries, and JavaScript embedding) to support this solution. By staging the enhancements (from basic map to advanced interactivity), we can deliver immediate value for the revaluation project and iteratively reach the full feature set envisioned in the design sessions.
