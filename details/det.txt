Here’s a detailed **JIRA ticket** you can raise for the **SVT End-to-End PoC** — connecting the **UI (PCF Canvas Page)** → **Custom API (Dataverse)** → **APIM** → **Valuation API (mocked for now)** → **SQL call structure**.
This ticket describes the full flow, dependencies, and validation steps — aligned to how you typically run your technical spikes or integration PoCs.

---

### **JIRA Ticket: SVT – End-to-End PoC (UI to Backend via APIM with Mock API Data)**

**Epic Link:** SVT Integration / SVT Architecture Foundation
**Component:** SVT – API and Data Integration
**Type:** Spike / PoC
**Priority:** High
**Status:** To Do
**Assignee:** [API Developer / Full Stack Dev]
**Reporter:** [Your Name]

---

### **Summary**

Perform an **end-to-end proof of concept (PoC)** to validate the integration flow between the **SVT UI (PCF Canvas Page)**, **Dataverse Custom API**, **APIM**, and the **Valuation API layer**, simulating data retrieval and response from the backend (mocked at API level).
This PoC will ensure all components (UI → Custom API → APIM → API → DB) are connected, configurable, and ready for real data integration in later sprints.

---

### **Objective**

Validate that data can be fetched from the SVT UI, passed through Dynamics Custom API and APIM, and received from the Valuation API (currently mocked), with placeholders for SQL query execution.
The PoC will confirm:

* Data flow connectivity
* Authentication (AAD → APIM)
* Request/response structure
* Pagination, filtering, and sorting parameter handling
* Response time benchmark for mock payloads

---

### **Scope**

This PoC covers:

1. **PCF / Canvas App**

   * A basic SVT grid UI (Manager Dashboard view)
   * 18–19 columns with dummy header mapping
   * Pagination (Page 1/2)
   * Sorting and filtering UI controls
   * Trigger API call via `OnVisible` or `Button.OnSelect`
2. **Dynamics Custom API (Dataverse layer)**

   * Create a custom API (e.g. `defra_SVTGetSalesData`)
   * Pass parameters (filter, sort, page, pageSize) to APIM
   * Add bearer token header for secured call
3. **APIM Layer**

   * Define a new endpoint `/svt/sales`
   * Mock backend API response using **APIM mock-response policy**
   * Apply transformation to simulate 500-record paged response
4. **Valuation API (Mocked)**

   * Mock JSON payload to simulate SQL query output with pagination metadata
   * Simulate parameters accepted: `billingAuthority`, `flag`, `sort`, `page`, `pageSize`
5. **SQL Layer (for later integration)**

   * Define expected SQL query pattern (OFFSET/FETCH)
   * No live DB calls in this PoC, only structure mock

---

### **Acceptance Criteria**

| # | Criteria                                                           | Expected Outcome                              |
| - | ------------------------------------------------------------------ | --------------------------------------------- |
| 1 | UI grid loads 500 mock records from backend                        | Mock data visible with correct column mapping |
| 2 | Top-level filter changes trigger new API call                      | API receives query parameters correctly       |
| 3 | Pagination buttons trigger next-page calls                         | Page 2 returns mock “next 500” dataset        |
| 4 | Sorting parameter (e.g., `SalePrice:asc`) flows through all layers | Response sorted accordingly in mock payload   |
| 5 | APIM returns mocked JSON within <1s                                | Response meets baseline latency               |
| 6 | API logs show trace from UI → Custom API → APIM → Mock API         | Full connectivity confirmed                   |
| 7 | Authentication works (AAD token via Custom API to APIM)            | 200 OK response authenticated                 |
| 8 | Console/Telemetry capture request/response                         | Logs available in Application Insights        |

---

### **Mock API Response Sample**

**URL:** `GET /svt/sales?billingAuthority=Cardiff&flag=Outlier&page=1&pageSize=500`

**Response (Mocked in APIM or API):**

```json
{
  "totalCount": 3521,
  "page": 1,
  "pageSize": 500,
  "records": [
    {
      "SaleId": 10998752,
      "TaskId": 556987,
      "UARN": 18741001,
      "Address": "12 Cambrian Street",
      "Postcode": "CF10 1XY",
      "BillingAuthority": "Cardiff",
      "TransactionDate": "2023-07-17",
      "SalePrice": 395000,
      "OutlierFlag": "Yes",
      "Ratio": 1.32,
      "TaskStatus": "New",
      "AssignedTo": "Unassigned"
    }
  ]
}
```

---

### **Expected Deliverables**

| Layer                | Deliverable                                                          | Owner                |
| -------------------- | -------------------------------------------------------------------- | -------------------- |
| **UI / PCF Team**    | Minimal grid to call Custom API and render mock data                 | [Front-end dev]      |
| **Custom API**       | Endpoint `/defra_SVTGetSalesData` connecting to APIM with parameters | [Power Platform dev] |
| **APIM**             | Route definition `/svt/sales` + mock-response policy                 | [API Gateway dev]    |
| **Valuation API**    | Mock controller `/sales` returning JSON as above                     | [Backend dev]        |
| **DB Team (Future)** | SQL query template with expected pagination/filter pattern           | [DBA]                |

---

### **Technical Notes**

* Authentication via AAD token (managed identity for Custom API)
* Use mock data JSON stored in Azure Blob or static file for API testing
* Enable tracing in Application Insights for request chain
* Cache behaviour not required for PoC (handled in next sprint)
* PowerFx script should trigger `Set(varResponse, CustomConnector.GetSVTData(...))`

---

### **Out of Scope**

* Real-time SQL queries
* Redis caching or APIM caching policies
* Assignment or write operations
* QA and Caseworker screens

---

### **Testing Plan**

| Test Case | Scenario                              | Expected Result               |
| --------- | ------------------------------------- | ----------------------------- |
| 1         | Load dashboard page                   | Returns 500 records           |
| 2         | Apply filter “Outlier = Yes”          | Returns filtered mock dataset |
| 3         | Click “Next Page”                     | Loads mock page 2             |
| 4         | Change sort to “SalePrice:desc”       | Returns sorted mock records   |
| 5         | Change Billing Authority to “Swansea” | New mock dataset loaded       |
| 6         | Monitor trace in APIM                 | Shows full call chain success |

---

### **Definition of Done**

✅ UI grid renders mock paged data
✅ API parameters flow through all layers correctly
✅ Mock data returned via APIM in <1s
✅ Logging enabled at APIM and API layers
✅ Ready to switch from mock to real SQL integration next sprint

---

Would you like me to create a **matching Jira task breakdown table** (subtasks for each layer: UI / Custom API / APIM / Backend) so you can copy-paste that into Jira under this story? It’ll help the team pick up their respective responsibilities directly.
