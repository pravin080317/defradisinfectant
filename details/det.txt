Great question ‚Äî and an important design decision.

---

## ‚úÖ **Recommendation: Use Stored Procedure to Generate Task Number**

### Why?

Because **task creation** involves:

* **Auto-incrementing Task ID** (sequential, unique, visible to users)
* **Insert into Task Table**
* **Audit + Ownership fields**
* **Conditional logic** (e.g., check if task already exists for that UPRN)

A **SQL stored procedure** is the **most scalable, auditable, and concurrency-safe** way to handle this.

---

## üí° Suggested Architecture

### üîß **Stored Procedure**: `usp_CreateSVTTask`

**Inputs:**

* `@uprn`
* `@origin` (`SystemGenerated` or `Manual`)
* `@createdBy`
* (Optionally: `@initialOwner` if assigning directly)

**Logic:**

* Check if a task already exists for the given UPRN (`AND IsActive = 1`)
* If not:

  * Get next task number (e.g., via identity or sequence)
  * Insert new row into `SVTTask` table:

    * `TaskId` (auto number)
    * `UPRN`, `Origin`, `Owner`, `Status`, `CreatedBy`, `CreatedOn`
* Return the new `TaskId` and status message

---

### üîÑ **Called From**:

#### Option 1: **Power Automate**

* Trigger: Scheduled flow (e.g. for overnight outlier batch)
* Action: HTTP call to Azure Function or Power Platform custom connector ‚Üí calls the stored procedure
* Advantage: No-code/low-code usage
* Caution: Avoid complex loops in Power Automate due to timeout risks

#### Option 2: **Custom API (preferred for manual creation from canvas page)**

* Canvas page (Manager screen or Caseworker screen) ‚Üí custom connector ‚Üí API (Dataverse Custom API or Azure Function) ‚Üí stored procedure
* Advantage: Controlled logic, scalable, easy to call from multiple front ends (Canvas App, MDA, etc.)

---

## ‚úÖ Benefits of Using Stored Procedure

| Feature               | Why It Helps                                                         |
| --------------------- | -------------------------------------------------------------------- |
| **Atomicity**         | Prevents duplicate Task creation                                     |
| **Concurrency-safe**  | Handles multiple calls in parallel (no Task ID conflict)             |
| **Centralised Logic** | Easier to maintain and audit                                         |
| **Auto-numbering**    | Uses SQL identity or sequence, not client-side GUID or random IDs    |
| **Auditing**          | You can log inserts and changes in a separate Audit table or trigger |

---

## üõ†Ô∏è Example: Stored Procedure Structure (Simplified)

```sql
CREATE PROCEDURE usp_CreateSVTTask
    @uprn VARCHAR(20),
    @origin VARCHAR(20), -- 'Manual' or 'SystemGenerated'
    @createdBy VARCHAR(50),
    @owner VARCHAR(50) = NULL
AS
BEGIN
    SET NOCOUNT ON;

    IF EXISTS (
        SELECT 1 FROM SVTTask WHERE uprn = @uprn AND IsActive = 1
    )
    BEGIN
        SELECT 'Task already exists' AS Message;
        RETURN;
    END

    INSERT INTO SVTTask (
        uprn, origin, createdBy, createdOn, owner
    )
    VALUES (
        @uprn, @origin, @createdBy, GETDATE(), @owner
    );

    SELECT SCOPE_IDENTITY() AS NewTaskId, 'Success' AS Message;
END
```

---

## üîö Final Suggestion

‚úÖ **Use Stored Procedure to handle core logic**
‚úÖ **Expose via API** (for Canvas Apps or Manual creation)
‚úÖ **Use Power Automate for batch-based generation**
‚úÖ **Use SQL identity or custom sequence for task numbers**

Would you like a version with audit table logging or rollback support too?
