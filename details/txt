import pandas as pd
import re
from datetime import datetime

# Define validation rules
COLUMN_RULES = {
    "BA Report No": {"max_length": 8, "required": True, "numeric": True},
    "BA Reference No": {"max_length": 25, "required": True},
    "Property Address": {"max_length": 600, "required": True},
    "Postcode": {"max_length": 8, "required": True},
    "Coded Reason For Report": {"required": True, "regex": r"^CR\d{2}$"},  # Must start with CR + digits
    "Date of Change": {"required": True, "date_format": "%d-%b-%y"},  # Date format: DD-Mon-YY
    "Band in Valuation List": {"required": True, "values": ["a", "b", "c", "d", "e", "f"]},
    "UPRN": {"max_length": 12, "numeric": True},
    "Occupier's Name": {"max_length": 35},
    "Billing Address": {"max_length": 175},
    "Contact Telephone Number": {"max_length": 15, "numeric": True},
    "Plan Available": {"values": ["Y", ""]},
    "Plan Reference No": {"max_length": 25},
    "Source of Information": {"required": True, "values": ["BA Inspector", "Third Party"]},
    "OS Grid Ref": {"max_length": 21, "regex": r"^\d{1,10} \d{1,10}$"},  # Format: X Y
    "Details of Alterations and other Remarks": {"max_length": 255},
}

# Function to validate data
def validate_data(file_path):
    # Read the file based on extension
    if file_path.endswith(".csv"):
        df = pd.read_csv(file_path, skiprows=3)  # Skip first 3 rows (Header & Index Row)
    elif file_path.endswith(".xlsx"):
        df = pd.read_excel(file_path, skiprows=3)  # Skip first 3 rows (Header & Index Row)
    else:
        print("Unsupported file format. Please provide CSV or Excel file.")
        return

    errors = []

    for index, row in df.iterrows():
        row_errors = []
        excel_row_num = index + 4  # Adjusting row number to match Excel file structure

        for col, rules in COLUMN_RULES.items():
            value = str(row.get(col, "")).strip()

            # Required field check
            if rules.get("required") and not value:
                row_errors.append(f"{col} is required")

            # Length check
            if rules.get("max_length") and len(value) > rules["max_length"]:
                row_errors.append(f"{col} exceeds max length ({rules['max_length']} chars)")

            # Numeric check
            if rules.get("numeric") and value and not value.isdigit():
                row_errors.append(f"{col} must be numeric")

            # Regex pattern check
            if rules.get("regex") and value and not re.match(rules["regex"], value):
                row_errors.append(f"{col} has invalid format")

            # Date format check
            if rules.get("date_format") and value:
                try:
                    datetime.strptime(value, rules["date_format"])
                except ValueError:
                    row_errors.append(f"{col} must be in format {rules['date_format']}")

            # Dropdown values check
            if rules.get("values") and value and value not in rules["values"]:
                row_errors.append(f"{col} must be one of {rules['values']}")

        if row_errors:
            errors.append({"Row": excel_row_num, "Errors": "; ".join(row_errors)})  # Match actual row numbers

    if errors:
        error_df = pd.DataFrame(errors)
        error_df.to_csv("Validation_Errors.csv", index=False)
        print("Validation completed. Errors found. Check Validation_Errors.csv")
    else:
        print("Validation completed successfully. No errors found.")

# Example usage
file_path = "your_file.xlsx"  # Change to your actual file path
validate_data(file_path)
